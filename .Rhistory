# Create a Leaflet map
map <- leaflet() %>%
addTiles() # Add default OpenStreetMap tiles
# Add clustered green areas to the map
if (!is.null(db$cluster)) {
# Add each cluster to the map with a different color
palette <- colorFactor(rainbow(max(db$cluster) + 1), domain = db$cluster)
for (i in 0:max(db$cluster)) {
cluster_indices <- which(db$cluster == i)
if (length(cluster_indices) > 0) {
cluster_coords <- coords[cluster_indices, , drop = FALSE]
map <- map %>%
addCircleMarkers(
lng = cluster_coords[,1],
lat = cluster_coords[,2],
fillColor = ifelse(i == 0, "#808080", palette(i)), # Grey for noise points
fillOpacity = 0.8,
color = "#000000",
weight = 1,
radius = 6,
group = paste("Cluster", i)
)
}
}
}
# Add a legend for clusters
map <- map %>%
addLegend(
"bottomright",
pal = palette,
values = db$cluster,
title = "Clusters",
labFormat = labelFormat(transform = function(x) { ifelse(x == 0, "Noise", paste("Cluster", x)) }),
opacity = 1
)
# Add layer control to allow toggling the cluster layers on and off
map <- map %>%
addLayersControl(
overlayGroups = paste("Cluster", 0:max(db$cluster)),
options = layersControlOptions(collapsed = FALSE)
)
return(map)
}
visualize_green_space_clusters(green_areas, eps = 500, minPts = 10)
visualize_green_space_clusters(green_areas, eps = 500, minPts = 5)
visualize_green_space_clusters(green_areas, eps = 100, minPts = 5)
library(dbscan)
library(sf)
# Assuming green_areas is your sf object containing the green spaces
green_areas <- st_as_sf(green_areas_data$osm_polygons)
library(dbscan)
library(sf)
# Assuming green_areas is your sf object containing the green spaces
green_areas <- st_as_sf(green_areas$osm_polygons)
centroids <- st_centroid(green_areas)
# Extract coordinates
coords <- st_coordinates(centroids)
# Use kNNdistplot to find a suitable eps
kNNdistplot(coords, k = minPts)
# Use kNNdistplot to find a suitable eps
kNNdistplot(coords, k = 4)
abline(h = 0.05, col = 'red', lwd = 2)  # Adjust the h value based on the plot
db <- dbscan(coords, eps = 900, minPts = 4)
db
library(sf)
library(leaflet)
library(factoextra) # for fviz_cluster()
visualize_green_space_hclust <- function(green_areas_data) {
if (!is.list(green_areas_data) || !all(c("osm_polygons") %in% names(green_areas_data))) {
stop("Invalid green_areas_data format. It should be a list containing 'osm_polygons'.")
}
green_areas <- st_as_sf(green_areas_data$osm_polygons)
centroids <- st_centroid(green_areas)
# Extract coordinates
coords <- st_coordinates(centroids)
# Perform hierarchical clustering
dist_matrix <- dist(coords)
hclust_res <- hclust(dist_matrix)
# Determine the number of clusters using silhouette method
sil_width <- silhouette(cutree(hclust_res, k = 2:10), dist_matrix)
optimal_clusters <- which.max(sil_width[, "avg.width"])
# Cut the dendrogram to create the optimal number of clusters
clusters <- cutree(hclust_res, optimal_clusters)
# Create a Leaflet map
map <- leaflet() %>%
addTiles() # Add default OpenStreetMap tiles
# Add clustered green areas to the map
palette <- colorFactor(rainbow(optimal_clusters), domain = clusters)
for (i in 1:optimal_clusters) {
cluster_points <- green_areas[clusters == i, ]
map <- map %>%
addCircleMarkers(
data = cluster_points,
fillColor = palette(i),
fillOpacity = 0.8,
color = "#000000",
weight = 1,
radius = 6,
group = paste("Cluster", i)
)
}
# Add a legend for clusters
map <- map %>%
addLegend(
"bottomright",
pal = palette,
values = clusters,
title = "Clusters",
labFormat = labelFormat(transform = function(x) { paste("Cluster", x) }),
opacity = 1
)
# Add layer control to allow toggling the cluster layers on and off
map <- map %>%
addLayersControl(
overlayGroups = paste("Cluster", 1:optimal_clusters),
options = layersControlOptions(collapsed = FALSE)
)
return(map)
}
visualize_green_space_hclust(green_areas)
green_areas <- data$green_areas
visualize_green_space_hclust(green_areas)
install.packages("cluster")
library(cluster)
visualize_green_space_hclust(green_areas)
dist_matrix <- dist(coords)
hclust_res <- hclust(dist_matrix)
# Determine the number of clusters
# You might want to inspect the dendrogram to choose a suitable number of clusters
plot(hclust_res)
num_clusters <- 3
cluster_assignments <- cutree(hclust_res, k = num_clusters)
# Check if the cluster assignments match the number of observations
if (length(cluster_assignments) != nrow(coords)) {
stop("The number of cluster assignments does not match the number of observations.")
}
# If they match, then we can proceed to calculate the silhouette widths
sil_widths <- silhouette(cluster_assignments, dist_matrix)
# Now let's find the average silhouette width for each cluster
avg_sil_widths <- sapply(unique(cluster_assignments), function(cl) {
mean(sil_widths[, 'sil_width'][cluster_assignments == cl])
})
print(avg_sil_widths)
# Add clustered green areas to the map
map <- leaflet() %>%
addTiles() # Add default OpenStreetMap tiles
# Define colors for the clusters
palette <- colorFactor(rainbow(num_clusters), domain = cluster_assignments)
# Add green areas to the map with cluster colors
for (i in 1:num_clusters) {
cluster_points <- green_areas[cluster_assignments == i, ]
map <- map %>%
addCircleMarkers(
data = st_coordinates(cluster_points),
fillColor = palette(i),
fillOpacity = 0.8,
color = "#000000",
weight = 1,
radius = 6,
group = paste("Cluster", i)
)
}
visualize_clusters <- function(centroids, cluster_assignments, avg_sil_widths) {
# Create a data frame with centroids and cluster assignments
cluster_data <- data.frame(coords = st_coordinates(centroids), cluster = cluster_assignments)
# Create a Leaflet map
map <- leaflet(cluster_data) %>%
addTiles() # Add default OpenStreetMap tiles
# Define a color palette
palette <- colorNumeric(palette = rainbow(length(avg_sil_widths)), domain = cluster_assignments)
# Add centroids to the map colored by their cluster assignment
map <- map %>%
addCircleMarkers(
~coords.X1, ~coords.X2,
color = ~palette(cluster),
popup = ~paste("Cluster:", cluster, "<br>", "Silhouette Width:", round(avg_sil_widths[cluster], 3)),
opacity = 1,
fillOpacity = 0.8
)
# Add a legend for clusters
map <- map %>%
addLegend(
"bottomright",
pal = palette,
values = cluster_assignments,
title = "Clusters",
opacity = 1
)
# Return the Leaflet map
return(map)
}
map <- visualize_clusters(centroids, cluster_assignments, avg_sil_widths)
visualize_clusters_on_map <- function(green_areas, cluster_assignments) {
# Ensure we have 'leaflet' and 'sf' available
if (!require(leaflet) || !require(sf)) {
stop("Please install 'leaflet' and 'sf' packages to use this function.")
}
# Ensure that the number of clusters matches the number of features in green_areas
if (length(cluster_assignments) != nrow(green_areas)) {
stop("The number of cluster assignments does not match the number of features in green_areas.")
}
# Create a Leaflet map
map <- leaflet(green_areas) %>%
addProviderTiles(providers$OpenStreetMap) # Add default OpenStreetMap tiles
# Define colors for clusters
pal <- colorFactor(rainbow(length(unique(cluster_assignments))), domain = cluster_assignments)
# Add the clustered green areas to the map
map <- map %>%
addPolygons(
fillColor = ~pal(cluster_assignments),
fillOpacity = 0.5,
color = "#444444",
weight = 1,
smoothFactor = 0.5,
popup = ~as.character(cluster_assignments),
group = "Clusters"
) %>%
addLayersControl(
overlayGroups = c("Clusters"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addLegend(
position = "bottomright",
pal = pal,
values = ~cluster_assignments,
title = "Cluster",
opacity = 1
)
# Return the map
return(map)
}
green_a <- st_as_sf(green_areas$osm_polygons)
map <- visualize_clusters_on_map(green_a, cluster_assignments)
map
# Add descriptive popups to the map visualization
map <- map %>%
addPolygons(
fillColor = ~pal(cluster_assignments),
fillOpacity = 0.5,
color = "#444444",
weight = 1,
smoothFactor = 0.5,
popup = ~paste("Cluster:", cluster_assignments,
"<br>Number of Green Spaces:", sapply(unique(cluster_assignments), function(cl) sum(cluster_assignments == cl)),
"<br>Average Area (sqm):", sapply(unique(cluster_assignments), function(cl) mean(st_area(green_areas[cluster_assignments == cl,])))),
group = "Clusters"
)
library(sf)
library(leaflet)
library(cluster) # for silhouette
library(rgeos) # for gConvexHull
library(sf)
library(leaflet)
library(cluster) # for silhouette
library(dplyr) # for data manipulation
# Function to perform hierarchical clustering and visualize clusters on a Leaflet map
visualize_green_space_hclust <- function(green_areas_data) {
if (!is.list(green_areas_data) || !all(c("osm_polygons") %in% names(green_areas_data))) {
stop("Invalid green_areas_data format. It should be a list containing 'osm_polygons'.")
}
green_areas <- st_as_sf(green_areas_data$osm_polygons)
centroids <- st_centroid(green_areas)
# Extract coordinates
coords <- st_coordinates(centroids)
# Perform hierarchical clustering
dist_matrix <- dist(coords)
hclust_res <- hclust(dist_matrix)
# Determine the optimal number of clusters using silhouette analysis
optimal_clusters <- 2 # Start with 2 clusters for silhouette analysis
max_avg_sil_width <- 0
for (k in 2:10) { # Check silhouette for k=2 to k=10 clusters
cluster_assignments <- cutree(hclust_res, k)
sil_widths <- silhouette(cluster_assignments, dist_matrix)
avg_sil_width <- mean(sil_widths[, 'sil_width'])
if (avg_sil_width > max_avg_sil_width) {
max_avg_sil_width <- avg_sil_width
optimal_clusters <- k
}
}
# Cut the dendrogram to create the optimal number of clusters
cluster_assignments <- cutree(hclust_res, optimal_clusters)
green_areas$cluster <- cluster_assignments
# Create convex hulls for each cluster
cluster_hulls <- green_areas %>%
group_by(cluster) %>%
summarise(geometry = st_convex_hull(st_union(geometry))) %>%
ungroup()
# Define colors for clusters
pal <- colorFactor(rainbow(optimal_clusters), domain = cluster_assignments)
# Create a Leaflet map
map <- leaflet() %>%
addProviderTiles(providers$OpenStreetMap) # Add default OpenStreetMap tiles
# Add the clustered green areas to the map
map <- map %>%
addPolygons(
data = green_areas,
fillColor = ~pal(cluster),
fillOpacity = 0.5,
color = "#444444",
weight = 1,
smoothFactor = 0.5,
popup = ~paste("Cluster:", cluster,
"<br>Number of Green Spaces:", length(cluster),
"<br>Average Area (sqm):", mean(st_area(green_areas[cluster == cluster, ]))),
group = "Green Spaces"
)
# Add convex hulls as a separate layer
map <- map %>%
addPolygons(
data = cluster_hulls,
fillColor = NA,
color = pal(cluster_hulls$cluster),
weight = 2,
dashArray = "3",
group = "Cluster Boundaries"
)
# Add layer control to allow toggling layers on and off
map <- map %>%
addLayersControl(
overlayGroups = c("Green Spaces", "Cluster Boundaries"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addLegend(
position = "bottomright",
pal = pal,
values = ~cluster,
title = "Cluster",
opacity = 1
)
# Return the map
return(map)
}
green_areas_data <- green_areas$osm_polygons
visualize_green_space_hclust(green_areas_data)
visualize_green_space_hclust(green_areas)
visualize_green_space_hclust(green_a)
visualize_green_space_hclust <- function(green_areas_data) {
# Check if green_areas_data is a list and contains 'osm_polygons'
if (!is.list(green_areas_data) || !"osm_polygons" %in% names(green_areas_data)) {
stop("Invalid green_areas_data format. It should be a list containing 'osm_polygons'.")
}
# Check if 'osm_polygons' is NULL or empty
if (is.null(green_areas_data$osm_polygons) || nrow(green_areas_data$osm_polygons) == 0) {
stop("'osm_polygons' is NULL or has no rows.")
}
# Convert to sf if it's not already an sf object
if (!inherits(green_areas_data$osm_polygons, "sf")) {
green_areas_data$osm_polygons <- st_as_sf(green_areas_data$osm_polygons)
}
green_areas <- green_areas_data$osm_polygons
centroids <- st_centroid(green_areas)
# Extract coordinates
coords <- st_coordinates(centroids)
# Perform hierarchical clustering
dist_matrix <- dist(coords)
hclust_res <- hclust(dist_matrix)
# Determine the optimal number of clusters using silhouette analysis
optimal_clusters <- 2 # Start with 2 clusters for silhouette analysis
max_avg_sil_width <- 0
for (k in 2:10) { # Check silhouette for k=2 to k=10 clusters
cluster_assignments <- cutree(hclust_res, k)
sil_widths <- silhouette(cluster_assignments, dist_matrix)
avg_sil_width <- mean(sil_widths[, 'sil_width'])
if (avg_sil_width > max_avg_sil_width) {
max_avg_sil_width <- avg_sil_width
optimal_clusters <- k
}
}
# Cut the dendrogram to create the optimal number of clusters
cluster_assignments <- cutree(hclust_res, optimal_clusters)
green_areas$cluster <- cluster_assignments
# Create convex hulls for each cluster
cluster_hulls <- green_areas %>%
group_by(cluster) %>%
summarise(geometry = st_convex_hull(st_union(geometry))) %>%
ungroup()
# Define colors for clusters
pal <- colorFactor(rainbow(optimal_clusters), domain = cluster_assignments)
# Create a Leaflet map
map <- leaflet() %>%
addProviderTiles(providers$OpenStreetMap) # Add default OpenStreetMap tiles
# Add the clustered green areas to the map
map <- map %>%
addPolygons(
data = green_areas,
fillColor = ~pal(cluster),
fillOpacity = 0.5,
color = "#444444",
weight = 1,
smoothFactor = 0.5,
popup = ~paste("Cluster:", cluster,
"<br>Number of Green Spaces:", length(cluster),
"<br>Average Area (sqm):", mean(st_area(green_areas[cluster == cluster, ]))),
group = "Green Spaces"
)
# Add convex hulls as a separate layer
map <- map %>%
addPolygons(
data = cluster_hulls,
fillColor = NA,
color = pal(cluster_hulls$cluster),
weight = 2,
dashArray = "3",
group = "Cluster Boundaries"
)
# Add layer control to allow toggling layers on and off
map <- map %>%
addLayersControl(
overlayGroups = c("Green Spaces", "Cluster Boundaries"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addLegend(
position = "bottomright",
pal = pal,
values = ~cluster,
title = "Cluster",
opacity = 1
)
# Return the map
return(map)
}
visualize_green_space_hclust(green_areas)
visualize_green_space_hclust(green_areas_data)
visualize_green_space_hclust(green_a)
visualize_green_space_hclust <- function(green_areas_data) {
# Check if green_areas_data is a list and contains 'osm_polygons'
if (!is.list(green_areas_data) || !"osm_polygons" %in% names(green_areas_data)) {
stop("Invalid green_areas_data format. It should be a list containing 'osm_polygons'.")
}
# Check if 'osm_polygons' is NULL or empty
if (is.null(green_areas_data$osm_polygons) || nrow(green_areas_data$osm_polygons) == 0) {
stop("'osm_polygons' is NULL or has no rows.")
}
# Ensure 'osm_polygons' is an sf object
if (!inherits(green_areas_data$osm_polygons, "sf")) {
stop("'osm_polygons' should be an 'sf' object.")
}
green_areas <- green_areas_data$osm_polygons
# Print the structure of green_areas for debugging
print(str(green_areas))
centroids <- st_centroid(green_areas)
# Extract coordinates
coords <- st_coordinates(centroids)
# Perform hierarchical clustering
dist_matrix <- dist(coords)
hclust_res <- hclust(dist_matrix)
# Determine the optimal number of clusters using silhouette analysis
optimal_clusters <- 2 # Start with 2 clusters for silhouette analysis
max_avg_sil_width <- 0
for (k in 2:10) { # Check silhouette for k=2 to k=10 clusters
cluster_assignments <- cutree(hclust_res, k)
sil_widths <- silhouette(cluster_assignments, dist_matrix)
avg_sil_width <- mean(sil_widths[, 'sil_width'])
if (avg_sil_width > max_avg_sil_width) {
max_avg_sil_width <- avg_sil_width
optimal_clusters <- k
}
}
# Cut the dendrogram to create the optimal number of clusters
cluster_assignments <- cutree(hclust_res, optimal_clusters)
green_areas$cluster <- cluster_assignments
# Create convex hulls for each cluster
cluster_hulls <- green_areas %>%
group_by(cluster) %>%
summarise(geometry = st_convex_hull(st_union(geometry))) %>%
ungroup()
# Define colors for clusters
pal <- colorFactor(rainbow(optimal_clusters), domain = cluster_assignments)
# Create a Leaflet map
map <- leaflet() %>%
addProviderTiles(providers$OpenStreetMap) # Add default OpenStreetMap tiles
# Add the clustered green areas to the map
map <- map %>%
addPolygons(
data = green_areas,
fillColor = ~pal(cluster),
fillOpacity = 0.5,
color = "#444444",
weight = 1,
smoothFactor = 0.5,
popup = ~paste("Cluster:", cluster,
"<br>Number of Green Spaces:", length(cluster),
"<br>Average Area (sqm):", mean(st_area(green_areas[cluster == cluster, ]))),
group = "Green Spaces"
)
# Add convex hulls as a separate layer
map <- map %>%
addPolygons(
data = cluster_hulls,
fillColor = NA,
color = pal(cluster_hulls$cluster),
weight = 2,
dashArray = "3",
group = "Cluster Boundaries"
)
# Add layer control to allow toggling layers on and off
map <- map %>%
addLayersControl(
overlayGroups = c("Green Spaces", "Cluster Boundaries"),
options = layersControlOptions(collapsed = FALSE)
) %>%
addLegend(
position = "bottomright",
pal = pal,
values = ~cluster,
title = "Cluster",
opacity = 1
)
# Return the map
return(map)
}
visualize_green_space_hclust(green_areas)
