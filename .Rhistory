#' @param loc The location from where accessibility is to be calculated (e.g., a coordinate pair as c(lon, lat)).
#' @param green_areas_data List containing green areas data (obtained from get_osm_data function).
#' @param highways_data List containing highways data (obtained from get_osm_data function).
#'
#' @return A Leaflet map displaying the accessibility polygons and green areas.
#'
#' @import leaflet
#' @import osrm
#' @examples
#' \dontrun{
#'   # Assuming you have already obtained green_areas_data and highways_data using get_osm_data
#'   visualize_accessibility(c(6.6322734, 46.5196535), green_areas_data, highways_data)
#' }
visualize_accessibility <- function(loc, green_areas_data, highways_data) {
# Ensure required data is available
if (!is.list(green_areas_data) || !is.list(highways_data)) {
stop("Invalid data format. Ensure you have the necessary data from get_osm_data function.")
}
# Prepare the osrm data
osrm_data <- osrm::osrmTable(src = loc, dst = sf::st_coordinates(highways_data$osm_lines))
# Create isochrone polygons for 5, 10, and 15 minutes walk
isochrones <- lapply(c(5, 10, 15), function(minutes) {
reachable <- osrm_data$durations <= minutes * 60  # Convert minutes to seconds
coords <- sf::st_coordinates(highways_data$osm_lines)[reachable, ]
polygon <- chull(coords)  # Convex hull to create polygon
sf::st_polygon(list(coords[polygon, ]))
})
# Create a Leaflet map
map <- leaflet() %>%
addTiles()  # Customize the basemap using other leaflet functions if needed
# Add isochrone polygons to the map
colors <- c("red", "blue", "green")
labels <- c("5-minute walk", "10-minute walk", "15-minute walk")
for(i in seq_along(isochrones)) {
map <- map %>%
addPolygons(
data = isochrones[[i]],
fillColor = colors[i],
fillOpacity = 0.5,
color = "black",
weight = 1,
label = labels[i]
)
}
# Add green areas polygons to the map
map <- map %>%
addPolygons(
data = green_areas_data$osm_polygons,
fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1,
group = "Green Spaces"
)
# Add a legend and layer control
map <- map %>%
addLegend(
"bottomright",
colors = c(colors, "green"),
labels = c(labels, "Green Space"),
opacity = 0.7
) %>%
addLayersControl(
overlayGroups = "Green Spaces",
options = layersControlOptions(collapsed = TRUE)
)
# Return the Leaflet map
return(map)
}
highways_data <- data$highways
accc <- visualize_accessibility(location, green_areas, highways_data)
accc <- visualize_accessibility(location, green_areas, highway_data)
highways_data <- data$highways$osm_lines
accc <- visualize_accessibility(location, green_areas, highways_data)
#' Visualize Accessibility to Green Areas
#'
#' This function visualizes the accessibility of green areas from any location within the network on a Leaflet map.
#' It creates polygons for 5-minute walk, 10-minute walk, and 15-minute walk based on the 15-minute city concept.
#'
#' @param loc The location from where accessibility is to be calculated (e.g., a coordinate pair as c(lon, lat)).
#' @param green_areas_data List containing green areas data (obtained from get_osm_data function).
#' @param highways_data List containing highways data (obtained from get_osm_data function).
#'
#' @return A Leaflet map displaying the accessibility polygons and green areas.
#'
#' @import leaflet
#' @import osrm
#' @examples
#' \dontrun{
#'   # Assuming you have already obtained green_areas_data and highways_data using get_osm_data
#'   visualize_accessibility(c(6.6322734, 46.5196535), green_areas_data, highways_data)
#' }
visualize_accessibility <- function(loc, green_areas_data, highways_data) {
# Ensure required data is available
if (!is.list(green_areas_data) || !is.list(highways_data)) {
stop("Invalid data format. Ensure you have the necessary data from get_osm_data function.")
}
# Convert location to a data.frame
loc_df <- data.frame(lon = loc[1], lat = loc[2])
# Extract coordinates from highways_data
highway_coords <- sf::st_coordinates(highways_data$osm_lines)
highway_coords_df <- data.frame(lon = highway_coords[, 1], lat = highway_coords[, 2])
# Prepare the osrm data
osrm_data <- osrm::osrmTable(src = loc_df, dst = highway_coords_df)
# Create isochrone polygons for 5, 10, and 15 minutes walk
isochrones <- lapply(c(5, 10, 15), function(minutes) {
reachable <- osrm_data$durations <= minutes * 60  # Convert minutes to seconds
coords <- highway_coords_df[reachable, ]
if(nrow(coords) >= 3) {
polygon <- chull(coords)  # Convex hull to create polygon
sf::st_polygon(list(coords[polygon, ]))
} else {
NULL  # Return NULL if there are not enough points to form a polygon
}
})
# Create a Leaflet map
map <- leaflet() %>%
addTiles()  # Customize the basemap using other leaflet functions if needed
# Add isochrone polygons to the map
colors <- c("red", "blue", "green")
labels <- c("5-minute walk", "10-minute walk", "15-minute walk")
for(i in seq_along(isochrones)) {
if(!is.null(isochrones[[i]])) {
map <- map %>%
addPolygons(
data = isochrones[[i]],
fillColor = colors[i],
fillOpacity = 0.5,
color = "black",
weight = 1,
label = labels[i]
)
}
}
# Add green areas polygons to the map
map <- map %>%
addPolygons(
data = green_areas_data$osm_polygons,
fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1,
group = "Green Spaces"
)
# Add a legend and layer control
map <- map %>%
addLegend(
"bottomright",
colors = c(colors, "green"),
labels = c(labels, "Green Space"),
opacity = 0.7
) %>%
addLayersControl(
overlayGroups = "Green Spaces",
options = layersControlOptions(collapsed = TRUE)
)
# Return the Leaflet map
return(map)
}
# Example Usage:
# Assuming you have already obtained green_areas_data and highways_data using get_osm_data
# location <- c(6.6322734, 46.5196535)  # Example location coordinates (longitude, latitude)
# accc <- visualize_accessibility(location, green_areas_data, highways_data)
highway_data <- data$highways
accc <- visualize_accessibility(location, green_areas, highways)
accc <- visualize_accessibility(location, green_areas, highways_data)
accc <- visualize_accessibility(location, green_areas, highway_data)
accc <- visualize_accessibility(location, green_areas, highway_data)
#' Visualize Accessibility to Green Areas
#'
#' This function visualizes the accessibility of green areas from any location within the network on a Leaflet map.
#' It creates polygons for 5-minute walk, 10-minute walk, and 15-minute walk based on the 15-minute city concept.
#'
#' @param loc The location from where accessibility is to be calculated (e.g., a coordinate pair as c(lon, lat)).
#' @param green_areas_data List containing green areas data (obtained from get_osm_data function).
#' @param highways_data List containing highways data (obtained from get_osm_data function).
#'
#' @return A Leaflet map displaying the accessibility polygons and green areas.
#'
#' @import leaflet
#' @import osrm
#' @examples
#' \dontrun{
#'   # Assuming you have already obtained green_areas_data and highways_data using get_osm_data
#'   visualize_accessibility(c(6.6322734, 46.5196535), green_areas_data, highways_data)
#' }
visualize_accessibility <- function(loc, green_areas_data, highways_data) {
# Ensure required data is available
if (!is.list(green_areas_data) || !is.list(highways_data) || is.null(highways_data$osm_lines) || !inherits(highways_data$osm_lines, "sf")) {
stop("Invalid data format. Ensure you have the necessary data from get_osm_data function.")
}
# Convert location to a data.frame
loc_df <- data.frame(lon = loc[1], lat = loc[2])
# Extract coordinates from highways_data
highway_coords <- sf::st_coordinates(highways_data$osm_lines)
highway_coords_df <- data.frame(lon = highway_coords[, 1], lat = highway_coords[, 2])
# Prepare the osrm data
osrm_data <- osrm::osrmTable(src = loc_df, dst = highway_coords_df)
# Create isochrone polygons for 5, 10, and 15 minutes walk
isochrones <- lapply(c(5, 10, 15), function(minutes) {
reachable <- osrm_data$durations <= minutes * 60  # Convert minutes to seconds
coords <- highway_coords_df[reachable, ]
if(nrow(coords) >= 3) {
polygon <- chull(coords)  # Convex hull to create polygon
sf::st_polygon(list(coords[polygon, ]))
} else {
NULL  # Return NULL if there are not enough points to form a polygon
}
})
# Create a Leaflet map
map <- leaflet() %>%
addTiles()  # Customize the basemap using other leaflet functions if needed
# Add isochrone polygons to the map
colors <- c("red", "blue", "green")
labels <- c("5-minute walk", "10-minute walk", "15-minute walk")
for(i in seq_along(isochrones)) {
if(!is.null(isochrones[[i]])) {
map <- map %>%
addPolygons(
data = isochrones[[i]],
fillColor = colors[i],
fillOpacity = 0.5,
color = "black",
weight = 1,
label = labels[i]
)
}
}
# Add green areas polygons to the map
map <- map %>%
addPolygons(
data = green_areas_data$osm_polygons,
fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1,
group = "Green Spaces"
)
# Add a legend and layer control
map <- map %>%
addLegend(
"bottomright",
colors = c(colors, "green"),
labels = c(labels, "Green Space"),
opacity = 0.7
) %>%
addLayersControl(
overlayGroups = "Green Spaces",
options = layersControlOptions(collapsed = TRUE)
)
# Return the Leaflet map
return(map)
}
# Example Usage:
# Assuming you have already obtained green_areas_data and highways_data using get_osm_data
# location <- c(6.6322734, 46.5196535)  # Example location coordinates (longitude, latitude)
# accc <- visualize_accessibility(location, green_areas_data, highways_data)
hd <- data$highways$osm_lines
ac <- visualize_accessibility(location, green_areas, hd)
str(hd$osm_lines)
hd <- data$highways
ac <- visualize_accessibility(location, green_areas, hd)
str(hd$osm_lines)
str(hd)
library(sf)
library(spNetwork)
library(tmap)
install.packages("concaveman")
library(concaveman)
library(smoothr)
install.packages("smoothr")
library(concaveman)
library(smoothr)
visualize_accessibility <- function(location, green_areas_data, highways_data) {
# Ensure required data is available
if (!is.list(green_areas_data) || !is.list(highways_data) || is.null(highways_data$osm_lines)) {
stop("Invalid data format. Ensure you have the necessary data from get_osm_data function.")
}
# Calculate the length of each segment
highways_data$osm_lines$length <- as.numeric(st_length(highways_data$osm_lines))
# Create a data frame for the starting location
df_center <- data.frame("OID" = 1,
"x" = location[1],
"y" = location[2])
df_center <- st_as_sf(df_center, coords = c("x","y"), crs = st_crs(highways_data$osm_lines))
# Calculate isochrones
iso_results <- spNetwork::calc_isochrones(
lines = highways_data$osm_lines,
start_points = df_center,
dists = c(500, 1000, 1500),  # Distances representing 5, 10, 15-minute walks (assuming a walking speed of 5 km/h)
weight = "length"
)
# Identify each isochrone
iso_results$iso_oid <- paste(iso_results$point_id,
iso_results$distance,
sep = "_")
# Create polygons for each isochrone using concave hulls
polygons <- lapply(unique(iso_results$iso_oid), function(oid){
lines <- subset(iso_results, iso_results$iso_oid == oid)
coords <- st_coordinates(lines)
poly_coords <- concaveman(points = coords, concavity = 3)
poly <- st_polygon(list(poly_coords[,1:2]))
return(poly)
})
# Create a SpatialPolygonsDataFrame
iso_sp <- st_sf(
iso_oid = unique(iso_results$iso_oid),
distance = unique(iso_results$distance),
geometry = polygons,
crs = st_crs(iso_results)
)
# Simplify and smooth the limits of the polygons
simple_polygons <- st_simplify(iso_sp, dTolerance = 50)
smooth_iso <- smooth(simple_polygons, method = "chaikin", refinements = 5)
# Visualize the isochrones and green areas
map <- tm_shape(highways_data$osm_lines) +
tm_lines(col = "black") +
tm_shape(smooth_iso) +
tm_polygons(col = "fac_dist",
title.col = "distance (m)",
palette = c("500"="#005f73", "1000"="#ca6702", "1500"="#9b2226"),
border.col = "white",
alpha = 0.6) +
tm_shape(green_areas_data$osm_polygons) +
tm_polygons(fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1,
group = "Green Spaces") +
tm_shape(df_center) +
tm_dots(col = "black", size = 0.1) +
tm_layout(legend.outside = TRUE)
return(map)
}
ac <- visualize_accessibility(location, green_areas, hd)
visualize_accessibility <- function(location, green_areas_data, highways_data) {
# Ensure required data is available
if (!is.list(green_areas_data) || !is.list(highways_data) || is.null(highways_data$osm_lines)) {
stop("Invalid data format. Ensure you have the necessary data from get_osm_data function.")
}
# Calculate the length of each segment
highways_data$osm_lines$length <- as.numeric(st_length(highways_data$osm_lines))
# Create a data frame for the starting location
df_center <- data.frame("OID" = 1,
"x" = location[1],
"y" = location[2])
df_center <- st_as_sf(df_center, coords = c("x","y"), crs = st_crs(highways_data$osm_lines))
# Calculate isochrones
iso_results <- spNetwork::calc_isochrones(
lines = highways_data$osm_lines,
start_points = df_center,
dists = c(500, 1000, 1500),  # Distances representing 5, 10, 15-minute walks (assuming a walking speed of 5 km/h)
weight = "length"
)
# Identify each isochrone
iso_results$iso_oid <- paste(iso_results$point_id,
iso_results$distance,
sep = "_")
# Create polygons for each isochrone using concave hulls
polygons <- lapply(unique(iso_results$iso_oid), function(oid){
lines <- subset(iso_results, iso_results$iso_oid == oid)
coords <- st_coordinates(lines)
poly_coords <- concaveman(points = coords, concavity = 3)
poly <- st_polygon(list(poly_coords[,1:2]))
return(poly)
})
# Create a SpatialPolygonsDataFrame
iso_sp <- st_sf(
iso_oid = unique(iso_results$iso_oid),
distance = unique(iso_results$distance),
geometry = polygons,
crs = st_crs(iso_results)
)
# Simplify and smooth the limits of the polygons
simple_polygons <- st_simplify(iso_sp, dTolerance = 50)
smooth_iso <- smooth(simple_polygons, method = "chaikin", refinements = 5)
# Visualize the isochrones and green areas
map <- tm_shape(highways_data$osm_lines) +
tm_lines(col = "black") +
tm_shape(smooth_iso) +
tm_polygons(col = "fac_dist",
title.col = "distance (m)",
palette = c("500"="#005f73", "1000"="#ca6702", "1500"="#9b2226"),
border.col = "white",
alpha = 0.6) +
tm_shape(green_areas_data$osm_polygons) +
tm_polygons(fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1) +  # Removed group argument here
tm_shape(df_center) +
tm_dots(col = "black", size = 0.1) +
tm_layout(legend.outside = TRUE)
return(map)
}
ac <- visualize_accessibility(location, green_areas, hd)
str(apotheke.sf)
library(greenR)
data <- get_osm_data("Basel, Switzerland")
map <- visualize_green_space(data$green_areas)
#' Visualize Green Spaces on a Leaflet Map
#'
#' This function visualizes green spaces on a Leaflet map using the green_areas_data obtained from the get_osm_data function.
#' Green spaces are labeled based on their tags and have different colors in the legend. Users can switch the green spaces layer on and off.
#'
#' @param green_areas_data List containing green areas data (obtained from get_osm_data function).
#'
#' @return A Leaflet map displaying green spaces with labels and a legend, with a layer control for toggling the green spaces layer.
#'
#' @import leaflet
#'
#' @examples
#' \dontrun{
#'   # Assuming you have already obtained green_areas_data using get_osm_data
#'   visualize_green_spaces(green_areas_data)
#' }
visualize_green_spaces <- function(green_areas_data) {
# Check if green_areas_data contains the required components
if (!is.list(green_areas_data) || !all(c("osm_polygons") %in% names(green_areas_data))) {
stop("Invalid green_areas_data format. It should be a list containing 'osm_polygons'.")
}
# Create a Leaflet map
map <- leaflet() %>%
addTiles() # You can customize the basemap using other leaflet functions
# Add green areas polygons to the map as a separate layer
if (!is.null(green_areas_data$osm_polygons)) {
map <- map %>%
addPolygons(
data = green_areas_data$osm_polygons,
fillColor = "green",
fillOpacity = 0.7,
color = "black",
weight = 1,
group = "Green Spaces"
)
}
# Add a legend
map <- map %>%
addLegend(
"bottomright",
colors = "green", # Legend color
labels = "Green Space", # Legend label
opacity = 0.7
)
# Add layer control to allow toggling the green spaces layer on and off
map <- map %>%
addLayersControl(
overlayGroups = "Green Spaces", # Group name for the green spaces layer
options = layersControlOptions(collapsed = TRUE) # Collapsed layer control
)
# Return the Leaflet map
return(map)
}
map <- visualize_green_space(data$green_areas)
mapp <- visualize_green_spaces(data$green_areas)
library(magrittr)
mapp <- visualize_green_spaces(data$green_areas)
library(leaflet)
mapp <- visualize_green_spaces(data$green_areas)
mapp
health_location <-
tibble(
case_id = c(1),
long = c(7.588836776447177
),
lat = c(
47.55859423575359
)
) %>%
st_as_sf(., coords = c("long", "lat"), crs = 4326, agr = "constant") %>%
st_transform(., crs = 4326)
library(sf)
library(tidyverse)
health_location <-
tibble(
case_id = c(1),
long = c(7.588836776447177
),
lat = c(
47.55859423575359
)
) %>%
st_as_sf(., coords = c("long", "lat"), crs = 4326, agr = "constant") %>%
st_transform(., crs = 4326)
green_area <- data$green_areas
tm_shape(green_area) +
tm_dots(size = 0.1,
col = "black")
library(tmap)
library(osrm)
tm_shape(green_area) +
tm_dots(size = 0.1,
col = "black")
green_area <- st_as_sf(green_area)
green_area
library(osrm)
osrmIsochrone(
health_location,
breaks = seq(from = 0, to = 60, length.out = 7),
exclude,
res = 30,
returnclass,
osrm.server = getOption("osrm.server"),
osrm.profile = getOption("osrm.profile")
)
iso <- osrmIsochrone(loc = c(13.43, 52.47), breaks = seq(0, 12, 2))
plot(iso["isomax"], breaks = sort(unique(c(iso$isomin, iso$isomax))))
iso <- osrmIsochrone(loc = c(13.43, 52.47), breaks = seq(0, 15, 5))
plot(iso["isomax"], breaks = sort(unique(c(iso$isomin, iso$isomax))))
library(greenR)
library(greenR)
library(greenR)
