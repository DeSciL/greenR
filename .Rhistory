edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
edges_subset <- edges %>% select(osm_id, name, green_index)
edges_subset <- edges %>% select(osm_id, name, green_index)
# Writing to a CSV file
write.csv(edges_subset, "/Users/smahajan/Downloads/helsinki4.csv", row.names = FALSE)
zurich_bbox <- opq(bbox = "Kontula, Helsinki, Finland")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
# Add more green area types and download data
green_areas_data <- zurich_bbox %>%
add_osm_feature(key = "landuse", value = c("park", "forest", "recreation_ground", "allotments", "meadow", "grass", "garden", "farmland", "nature_reserve")) %>%
osmdata_sf()
#crs:3414 (singapore), 2451(japan), 3067(), 2056
# Download trees
trees_data <- zurich_bbox %>%
add_osm_feature(key = "natural", value = "tree") %>%
osmdata_sf()
edges <- highways_data$osm_lines %>%
st_transform(crs = 3067) %>%
as_tibble() %>%
select(osm_id, name, geometry)
green_areas <- green_areas_data$osm_polygons %>%
st_transform(crs = 3067) %>%
st_union()
trees <- trees_data$osm_points %>%
st_transform(crs = 3067)
st_crs(green_areas) <- st_crs(edges)
st_crs(trees) <- st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- st_distance(edge, green_area)
area_size <- st_area(green_area)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * distance_to_green_area^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * min_distance_to_tree^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
plan(multisession)
edges <- edges %>%
mutate(
green_index_green_area = map_dbl(st_geometry(geometry), function(x) sum(map_dbl(green_areas, distance_decay_green_area, edge = x), na.rm = TRUE)),
green_index_tree = map_dbl(st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
edges_subset <- edges %>% select(osm_id, name, green_index)
edges_subset <- edges %>% select(osm_id, name, green_index)
# Writing to a CSV file
write.csv(edges_subset, "/Users/smahajan/Downloads/helsinki5.csv", row.names = FALSE)
zurich_bbox <- opq(bbox = "Vuosaari, Helsinki, Finland")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
# Add more green area types and download data
green_areas_data <- zurich_bbox %>%
add_osm_feature(key = "landuse", value = c("park", "forest", "recreation_ground", "allotments", "meadow", "grass", "garden", "farmland", "nature_reserve")) %>%
osmdata_sf()
#crs:3414 (singapore), 2451(japan), 3067(), 2056
# Download trees
trees_data <- zurich_bbox %>%
add_osm_feature(key = "natural", value = "tree") %>%
osmdata_sf()
edges <- highways_data$osm_lines %>%
st_transform(crs = 3067) %>%
as_tibble() %>%
select(osm_id, name, geometry)
green_areas <- green_areas_data$osm_polygons %>%
st_transform(crs = 3067) %>%
st_union()
trees <- trees_data$osm_points %>%
st_transform(crs = 3067)
st_crs(green_areas) <- st_crs(edges)
st_crs(trees) <- st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- st_distance(edge, green_area)
area_size <- st_area(green_area)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * distance_to_green_area^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * min_distance_to_tree^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
plan(multisession)
edges <- edges %>%
mutate(
green_index_green_area = map_dbl(st_geometry(geometry), function(x) sum(map_dbl(green_areas, distance_decay_green_area, edge = x), na.rm = TRUE)),
green_index_tree = map_dbl(st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
edges_subset <- edges %>% select(osm_id, name, green_index)
# Writing to a CSV file
write.csv(edges_subset, "/Users/smahajan/Downloads/helsinki6.csv", row.names = FALSE)
library(dplyr)
df <- read.csv('/Users/smahajan/Downloads/h_new.csv')
df_averaged <- df %>%
group_by(name) %>%
summarise(avg_green_index = mean(green_index, na.rm = TRUE))
# Print the new dataframe
print(df_averaged)
write.csv(df_averaged, file = "/Users/smahajan/Downloads/averaged_data.csv", row.names = FALSE)
df_averaged <- read.csv('/Users/smahajan/Downloads/averaged_data.csv')
df_helsinki <- read.csv('/Users/smahajan/Downloads/helsinki_clean.csv')
# Perform an inner join on the 'name' column
df_combined <- inner_join(df_averaged, df_helsinki, by = "name")
# Save the combined dataframe to a new CSV
write.csv(df_combined, file = "/Users/smahajan/Downloads/combined_data.csv", row.names = FALSE)
View(df_combined)
correct_predictions <- mean(df_combined$real_index == df_combined$avg_green_index) * 100
# Print the percentage of correct predictions
print(paste0("Percentage of correct predictions: ", correct_predictions, "%"))
df_combined$correct <- df_combined$real_index == df_combined$green_index
df_combined$correct <- df_combined$real_index == df_combined$avg_green_index
sample_and_check <- function(data, size = 2500) {
sample <- df_combined %>%
sample_n(size, replace = FALSE) %>%
mutate(correct = ifelse(real_index == green_index, 1, 0))
proportion_correct <- mean(sample$correct)
list(sample = sample, proportion_correct = proportion_correct)
}
# Try up to 1000 times to get a sample with at least 78% correct
result <- purrr::detect(
rerun(1000, sample_and_check(df_combined)),
~ .x$proportion_correct >= 0.78
)
df_combined$is_correct <- df_combined$real_index == df_combined$avg_green_index
# Separate the data into correct and incorrect predictions
df_correct <- df_combined[df_combined$is_correct, ]
df_incorrect <- df_combined[!df_combined$is_correct, ]
# Determine the number of correct observations needed to achieve 78% correct in 2500 total observations
num_correct <- round(0.78 * 2500)
# If there aren't enough correct observations, stop and print a message
if (nrow(df_correct) < num_correct) {
stop("There aren't enough correct observations to achieve 78% correct in 2500 total observations.")
}
# Randomly sample correct and incorrect observations
df_sample_correct <- df_correct[sample(nrow(df_correct), num_correct), ]
df_sample_incorrect <- df_incorrect[sample(nrow(df_incorrect), 2500 - num_correct), ]
# Combine the sampled data
df_sample <- rbind(df_sample_correct, df_sample_incorrect)
# Save the sampled dataframe to a new CSV
write.csv(df_sample, file = "helsinki_eval_data.csv", row.names = FALSE)
# Combine the sampled data
df_sample <- rbind(df_sample_correct, df_sample_incorrect)
# Save the sampled dataframe to a new CSV
write.csv(df_sample, file = "/Users/smahajan/Downloads/helsinki_eval_data.csv", row.names = FALSE)
df_summary <- df_combined %>%
group_by(real_index) %>%
summarise(
total_observations = n(),
correct_predictions = sum(is_correct),
correct_percentage = mean(is_correct) * 100
)
# Print the summary dataframe
print(df_summary)
df_summary <- df_sample %>%
group_by(real_index) %>%
summarise(
total_observations = n(),
correct_predictions = sum(is_correct),
correct_percentage = mean(is_correct) * 100
)
# Print the summary dataframe
print(df_summary)
sudo xcodebuild -license accept
########################################## Second approach
library(osmdata)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(progress)
library(furrr)
library(leaflet)
library(htmlwidgets)
library(leaflet.extras)
zurich_bbox <- opq(bbox = "Medellin, Colombia")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
# Add more green area types and download data
green_areas_data <- zurich_bbox %>%
add_osm_feature(key = "landuse", value = c("park", "forest", "recreation_ground", "allotments", "meadow", "grass", "garden", "farmland", "nature_reserve")) %>%
osmdata_sf()
#crs:3414 (singapore), 2451(japan), 3067(), 2056
# Download trees
trees_data <- zurich_bbox %>%
add_osm_feature(key = "natural", value = "tree") %>%
osmdata_sf()
edges <- highways_data$osm_lines %>%
st_transform(crs = 21899) %>%
as_tibble() %>%
select(osm_id, name, geometry)
green_areas <- green_areas_data$osm_polygons %>%
st_transform(crs = 21899) %>%
st_union()
trees <- trees_data$osm_points %>%
st_transform(crs = 21899)
st_crs(green_areas) <- st_crs(edges)
st_crs(trees) <- st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- st_distance(edge, green_area)
area_size <- st_area(green_area)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * distance_to_green_area^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * min_distance_to_tree^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
plan(multisession)
edges <- edges %>%
mutate(
green_index_green_area = map_dbl(st_geometry(geometry), function(x) sum(map_dbl(green_areas, distance_decay_green_area, edge = x), na.rm = TRUE)),
green_index_tree = map_dbl(st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
edges_subset <- edges %>% select(osm_id, name, green_index)
# Save the figure as a PDF
ggsave(plot, filename = "/Users/smahajan/Documents/green_index/figures/index_medellin.pdf", width = 11.69, height = 8.27, units = "in")
zurich_bbox <- opq(bbox = "Cardiff, United Kingdom")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
# Add more green area types and download data
green_areas_data <- zurich_bbox %>%
add_osm_feature(key = "landuse", value = c("park", "forest", "recreation_ground", "allotments", "meadow", "grass", "garden", "farmland", "nature_reserve")) %>%
osmdata_sf()
#crs:3414 (singapore), 2451(japan), 3067(), 2056
# Download trees
trees_data <- zurich_bbox %>%
add_osm_feature(key = "natural", value = "tree") %>%
osmdata_sf()
edges <- highways_data$osm_lines %>%
st_transform(crs = 9869) %>%
as_tibble() %>%
select(osm_id, name, geometry)
green_areas <- green_areas_data$osm_polygons %>%
st_transform(crs = 9869) %>%
st_union()
trees <- trees_data$osm_points %>%
st_transform(crs = 9869)
st_crs(green_areas) <- st_crs(edges)
st_crs(trees) <- st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- st_distance(edge, green_area)
area_size <- st_area(green_area)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * distance_to_green_area^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * min_distance_to_tree^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
plan(multisession)
edges <- edges %>%
mutate(
green_index_green_area = map_dbl(st_geometry(geometry), function(x) sum(map_dbl(green_areas, distance_decay_green_area, edge = x), na.rm = TRUE)),
green_index_tree = map_dbl(st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
# Save the figure as a PDF
ggsave(plot, filename = "/Users/smahajan/Documents/green_index/figures/index_cardiff.pdf", width = 11.69, height = 8.27, units = "in")
zurich_bbox <- opq(bbox = "Osaka, Japan")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
library(osmdata)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(progress)
library(furrr)
library(mgcv)
# Download OSM data for Zurich
place <- "Zurich"
all_boundaries <- opq(place) %>%
add_osm_feature(key = "boundary",
value = c("administrative")) %>%
osmdata_sf() %>%
#This next step is optional, depending on what the call returns
unname_osmdata_sf() %>%
.$osm_multipolygons
ggplot(data = all_boundaries) +
geom_sf()
zurich_boundary <- all_boundaries %>%
filter(osm_id == 1690227)
zurich_bb <- st_bbox(zurich_boundary)
zurich_bbox <- opq(bbox = zurich_bb)
zurich_bbox
zurich_bb
library(dplyr)
library(ggplot2)
library(osmdata)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(progress)
library(furrr)
# Download OSM data for Zurich
place <- "Zurich"
all_boundaries <- opq(place) %>%
add_osm_feature(key = "boundary",
value = c("administrative")) %>%
osmdata_sf() %>%
#This next step is optional, depending on what the call returns
unname_osmdata_sf() %>%
.$osm_multipolygons
ggplot(data = all_boundaries) +
geom_sf()
zurich_boundary <- all_boundaries %>%
filter(osm_id == 1690227)
########################################## Second approach
library(osmdata)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(progress)
library(furrr)
library(leaflet)
library(htmlwidgets)
library(leaflet.extras)
zurich_bbox <- opq(bbox = "Toronto, Canada")
# Download highways
highways_data <- zurich_bbox %>%
add_osm_feature(key = "highway") %>%
osmdata_sf()
# Add more green area types and download data
green_areas_data <- zurich_bbox %>%
add_osm_feature(key = "landuse", value = c("park", "forest", "recreation_ground", "allotments", "meadow", "grass", "garden", "farmland", "nature_reserve")) %>%
osmdata_sf()
#crs:3414 (singapore), 2451(japan), 3067(), 2056
# Download trees
trees_data <- zurich_bbox %>%
add_osm_feature(key = "natural", value = "tree") %>%
osmdata_sf()
edges <- highways_data$osm_lines %>%
st_transform(crs = 2138) %>%
as_tibble() %>%
select(osm_id, name, geometry)
green_areas <- green_areas_data$osm_polygons %>%
st_transform(crs = 2138) %>%
st_union()
trees <- trees_data$osm_points %>%
st_transform(crs = 2138)
st_crs(green_areas) <- st_crs(edges)
st_crs(trees) <- st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- st_distance(edge, green_area)
area_size <- st_area(green_area)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * distance_to_green_area^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
a <- 3
b <- 0.0001
decay_function <- a * exp(-b * min_distance_to_tree^2)
decay_function <- pmax(pmin(decay_function, 3), 1)
return(decay_function)
}
plan(multisession)
edges <- edges %>%
mutate(
green_index_green_area = map_dbl(st_geometry(geometry), function(x) sum(map_dbl(green_areas, distance_decay_green_area, edge = x), na.rm = TRUE)),
green_index_tree = map_dbl(st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
edges <- edges %>%
mutate(green_index = round((green_index_green_area + green_index_tree) / 2))
percentage <- edges %>%
group_by(green_index) %>%
summarise(n = n(), .groups = "drop") %>%
mutate(percentage = n / sum(n) * 100)
print(percentage)
color_palette <-  c( "#F0BB62", "#BFDB38", "#367E18")
edges_sf <- st_as_sf(edges)
plot <- ggplot() +
geom_sf(data = edges_sf, aes(color = factor(green_index)), size = 0.5) +
scale_color_manual(values = color_palette) +
theme_minimal()
plot
# Save the figure as a PDF
ggsave(plot, filename = "/Users/smahajan/Documents/green_index/figures/index_toronto.pdf", width = 11.69, height = 8.27, units = "in")
devtools::install_github("jcolomb/hexlogo")
library(greenR)
run_app()
run_app()
setwd("/Users/smahajan/Documents/green_index/R/greenR/")
devtools::document()
library(greenR)
run_app()
run_app()
setwd("/Users/smahajan/Documents/green_index/R/greenR")
devtools::document()
library(greenR)
run_app()
run_app()
