future::plan(future::multisession)
batch_results <- future.apply::future_sapply(batch, function(edge_wkt) {
calculate_green_index_edge(edge_wkt, con, D)
}, simplify = FALSE)
results <- c(results, batch_results)
}
# Combine results
green_index_green_area <- sapply(results, function(x) x["green_area"])
green_index_tree <- sapply(results, function(x) x["tree"])
edges <- highways_data %>%
mutate(
green_index_green_area = green_index_green_area,
green_index_tree = green_index_tree
)
# Compute normalized green index
edges <- edges %>%
mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
dbDisconnect(con)
return(edges)
}
library(greenR)
data <- get_osm_data("Medellin, Colombia")
#' Calculate green index for each edge
#'
#' This function calculates the green index for each edge in the road network.
#'
#' @param osm_data The OpenStreetMap data. This should be a list with three components:
#'                 highways, green_areas, and trees. Each component should be a spatial data frame.
#'                 You can use the osmdata package to get the required data.
#' @param crs_code The EPSG code for the Coordinate Reference System (CRS).
#' @param D The decay parameter in the decay function, default is 100.
#' @return A data frame with the green index for each edge.
#' @export
#' @examples
#' \dontrun{
#' # osm_data should be a list with three components: highways, green_areas, and trees
#' # You can use osmdata package to get this data.
#' calculate_green_index(osm_data, 2056, D = 100)
#' }
green_index_1 <- function(osm_data, crs_code, D = 100) {
# Extract data from the list
highways_data <- osm_data$highways
green_areas_data <- osm_data$green_areas
trees_data <- osm_data$trees
edges <- highways_data$osm_lines %>%
sf::st_transform(crs = crs_code) %>%
tibble::as_tibble() %>%
dplyr::select(osm_id, geometry)
green_areas <- green_areas_data$osm_polygons %>%
sf::st_transform(crs = crs_code) %>%
sf::st_union()
trees <- trees_data$osm_points %>%
sf::st_transform(crs = crs_code)
sf::st_crs(green_areas) <- sf::st_crs(edges)
sf::st_crs(trees) <- sf::st_crs(edges)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- sf::st_distance(edge, green_area)
decay_function <- exp(-(distance_to_green_area/D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- sf::st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
decay_function <- exp(-(min_distance_to_tree/D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
future::plan(future::multisession)
edges <- edges %>%
dplyr::mutate(
green_index_green_area = purrr::map_dbl(sf::st_geometry(geometry), function(x) sum(purrr::map_dbl(green_areas, ~distance_decay_green_area(x, .x), na.rm = TRUE))),
green_index_tree = purrr::map_dbl(sf::st_geometry(geometry), function(x) distance_decay_tree(x, trees))
)
# Compute normalized green index
edges <- edges %>%
dplyr::mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index)) / (max(green_index) - min(green_index))
)
end_time <- Sys.time()    # Record the end time
elapsed_time <- end_time - start_time
message("Green index calculation completed in: ", round(elapsed_time, 2), " ", units(elapsed_time))
return(edges)
}
index_original <- green_index_1(data, 6257, 100)
library(duckdb)
library(sf)
library(future.apply)
library(tibble)
library(dplyr)
library(purrr)
library(DBI)
# Function to convert sf objects to WKT format
sf_to_wkt <- function(sf_obj, crs_code) {
sf_obj <- st_transform(sf_obj, crs = crs_code)
sf_obj$wkt_geometry <- st_as_text(st_geometry(sf_obj))
sf_obj <- st_drop_geometry(sf_obj)
return(sf_obj)
}
# Function to calculate green index for each edge
calculate_index <- function(osm_data, crs_code, D = 100) {
# Establish DuckDB connection
db_path <- tempfile(fileext = ".duckdb")
con <- dbConnect(duckdb::duckdb(), db_path)
# Load spatial extension
dbExecute(con, "INSTALL spatial;")
dbExecute(con, "LOAD spatial;")
# Convert and write spatial data into DuckDB
highways_data <- sf_to_wkt(osm_data$highways$osm_lines, crs_code)
green_areas_data <- sf_to_wkt(osm_data$green_areas$osm_polygons, crs_code)
trees_data <- sf_to_wkt(osm_data$trees$osm_points, crs_code)
dbWriteTable(con, "highways", highways_data, overwrite = TRUE)
dbWriteTable(con, "green_areas", green_areas_data, overwrite = TRUE)
dbWriteTable(con, "trees", trees_data, overwrite = TRUE)
# Ensure spatial index creation for efficient spatial queries
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_green_areas ON green_areas (wkt_geometry);")
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_trees ON trees (wkt_geometry);")
# Define the distance decay functions
safe_distance_decay_green_area <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM green_areas;", edge_wkt)
distance_to_green_area <- dbGetQuery(con, query)$distance
if (is.na(distance_to_green_area)) return(0)
decay_function <- exp(-(distance_to_green_area / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(sum(decay_function, na.rm = TRUE))
}
safe_distance_decay_tree <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM trees;", edge_wkt)
distance_to_tree <- dbGetQuery(con, query)$distance
if (is.na(distance_to_tree)) return(0)
decay_function <- exp(-(distance_to_tree / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
# Perform calculations
edges <- highways_data %>%
rowwise() %>% # Ensure row-wise calculations
mutate(
green_index_green_area = safe_distance_decay_green_area(wkt_geometry, con, D),
green_index_tree = safe_distance_decay_tree(wkt_geometry, con, D)
) %>%
ungroup() # Ungroup after calculations
# Compute normalized green index
edges <- edges %>%
mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
dbDisconnect(con)
return(edges)
}
index_new <- calculate_index_1(data, 6257, 100)
index_new <- calculate_index(data, 6257, 100)
library(duckdb)
library(sf)
library(future.apply)
library(tibble)
library(dplyr)
library(purrr)
library(DBI)
# Function to convert sf objects to WKT format
sf_to_wkt <- function(sf_obj, crs_code) {
sf_obj <- st_transform(sf_obj, crs = crs_code)
sf_obj$wkt_geometry <- st_as_text(st_geometry(sf_obj))
sf_obj <- st_drop_geometry(sf_obj)
return(sf_obj)
}
# Function to calculate green index for each edge
calculate_index <- function(osm_data, crs_code, D = 100) {
# Establish DuckDB connection
db_path <- tempfile(fileext = ".duckdb")
con <- dbConnect(duckdb::duckdb(), db_path)
# Load spatial extension
dbExecute(con, "INSTALL spatial;")
dbExecute(con, "LOAD spatial;")
# Convert and write spatial data into DuckDB
highways_data <- sf_to_wkt(osm_data$highways$osm_lines, crs_code)
green_areas_data <- sf_to_wkt(osm_data$green_areas$osm_polygons, crs_code)
trees_data <- sf_to_wkt(osm_data$trees$osm_points, crs_code)
dbWriteTable(con, "highways", highways_data, overwrite = TRUE)
dbWriteTable(con, "green_areas", green_areas_data, overwrite = TRUE)
dbWriteTable(con, "trees", trees_data, overwrite = TRUE)
# Ensure spatial index creation for efficient spatial queries
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_green_areas ON green_areas (wkt_geometry);")
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_trees ON trees (wkt_geometry);")
# Define the distance decay functions
safe_distance_decay_green_area <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM green_areas;", edge_wkt)
distance_to_green_area <- dbGetQuery(con, query)$distance
if (is.na(distance_to_green_area)) return(0)
decay_function <- exp(-(distance_to_green_area / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(sum(decay_function, na.rm = TRUE))
}
safe_distance_decay_tree <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM trees;", edge_wkt)
distance_to_tree <- dbGetQuery(con, query)$distance
if (is.na(distance_to_tree)) return(0)
decay_function <- exp(-(distance_to_tree / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
# Perform calculations in parallel
plan(multisession)
edges <- highways_data %>%
future_rowwise() %>%
mutate(
green_index_green_area = safe_distance_decay_green_area(wkt_geometry, con, D),
green_index_tree = safe_distance_decay_tree(wkt_geometry, con, D)
) %>%
ungroup()
# Compute normalized green index
edges <- edges %>%
mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
dbDisconnect(con)
return(edges)
}
index_new <- calculate_index(data, 6257, 100)
install.packages("future.apply")
library(future.apply)
library(greenR)
data <- get_osm_data("Medellin, Colombia")
library(duckdb)
library(sf)
library(future.apply)
library(tibble)
library(dplyr)
library(purrr)
library(DBI)
# Function to convert sf objects to WKT format
sf_to_wkt <- function(sf_obj, crs_code) {
sf_obj <- st_transform(sf_obj, crs = crs_code)
sf_obj$wkt_geometry <- st_as_text(st_geometry(sf_obj))
sf_obj <- st_drop_geometry(sf_obj)
return(sf_obj)
}
# Function to calculate green index for each edge
calculate_index <- function(osm_data, crs_code, D = 100) {
# Establish DuckDB connection
db_path <- tempfile(fileext = ".duckdb")
con <- dbConnect(duckdb::duckdb(), db_path)
# Load spatial extension
dbExecute(con, "INSTALL spatial;")
dbExecute(con, "LOAD spatial;")
# Convert and write spatial data into DuckDB
highways_data <- sf_to_wkt(osm_data$highways$osm_lines, crs_code)
green_areas_data <- sf_to_wkt(osm_data$green_areas$osm_polygons, crs_code)
trees_data <- sf_to_wkt(osm_data$trees$osm_points, crs_code)
dbWriteTable(con, "highways", highways_data, overwrite = TRUE)
dbWriteTable(con, "green_areas", green_areas_data, overwrite = TRUE)
dbWriteTable(con, "trees", trees_data, overwrite = TRUE)
# Ensure spatial index creation for efficient spatial queries
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_green_areas ON green_areas (wkt_geometry);")
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_trees ON trees (wkt_geometry);")
# Define the distance decay functions
safe_distance_decay_green_area <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM green_areas;", edge_wkt)
distance_to_green_area <- dbGetQuery(con, query)$distance
if (is.na(distance_to_green_area)) return(0)
decay_function <- exp(-(distance_to_green_area / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(sum(decay_function, na.rm = TRUE))
}
safe_distance_decay_tree <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM trees;", edge_wkt)
distance_to_tree <- dbGetQuery(con, query)$distance
if (is.na(distance_to_tree)) return(0)
decay_function <- exp(-(distance_to_tree / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
# Perform calculations in parallel
plan(multisession)
edges <- highways_data %>%
future_rowwise() %>%
mutate(
green_index_green_area = safe_distance_decay_green_area(wkt_geometry, con, D),
green_index_tree = safe_distance_decay_tree(wkt_geometry, con, D)
) %>%
ungroup()
# Compute normalized green index
edges <- edges %>%
mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
dbDisconnect(con)
return(edges)
}
index_new <- calculate_index(data, 6257, 100)
library(duckdb)
library(sf)
library(future.apply)
library(tibble)
library(dplyr)
library(purrr)
library(DBI)
# Function to convert sf objects to WKT format
sf_to_wkt <- function(sf_obj, crs_code) {
sf_obj <- st_transform(sf_obj, crs = crs_code)
sf_obj$wkt_geometry <- st_as_text(st_geometry(sf_obj))
sf_obj <- st_drop_geometry(sf_obj)
return(sf_obj)
}
# Function to calculate green index for each edge
calculate_index <- function(osm_data, crs_code, D = 100) {
# Establish DuckDB connection
db_path <- tempfile(fileext = ".duckdb")
con <- dbConnect(duckdb::duckdb(), db_path)
# Load spatial extension
dbExecute(con, "INSTALL spatial;")
dbExecute(con, "LOAD spatial;")
# Convert and write spatial data into DuckDB
highways_data <- sf_to_wkt(osm_data$highways$osm_lines, crs_code)
green_areas_data <- sf_to_wkt(osm_data$green_areas$osm_polygons, crs_code)
trees_data <- sf_to_wkt(osm_data$trees$osm_points, crs_code)
dbWriteTable(con, "highways", highways_data, overwrite = TRUE)
dbWriteTable(con, "green_areas", green_areas_data, overwrite = TRUE)
dbWriteTable(con, "trees", trees_data, overwrite = TRUE)
# Ensure spatial index creation for efficient spatial queries
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_green_areas ON green_areas (wkt_geometry);")
dbExecute(con, "CREATE INDEX IF NOT EXISTS idx_trees ON trees (wkt_geometry);")
# Define the distance decay functions
safe_distance_decay_green_area <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM green_areas;", edge_wkt)
distance_to_green_area <- dbGetQuery(con, query)$distance
if (is.na(distance_to_green_area)) return(0)
decay_function <- exp(-(distance_to_green_area / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(sum(decay_function, na.rm = TRUE))
}
safe_distance_decay_tree <- function(edge_wkt, con, D) {
query <- sprintf("
SELECT MIN(ST_Distance(ST_GeomFromText('%s'), ST_GeomFromText(wkt_geometry))) AS distance
FROM trees;", edge_wkt)
distance_to_tree <- dbGetQuery(con, query)$distance
if (is.na(distance_to_tree)) return(0)
decay_function <- exp(-(distance_to_tree / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
# Perform calculations in parallel
plan(multisession)
edges <- highways_data %>%
rowwise() %>%
mutate(
green_index_green_area = safe_distance_decay_green_area(wkt_geometry, con, D),
green_index_tree = safe_distance_decay_tree(wkt_geometry, con, D)
) %>%
ungroup()
# Compute normalized green index
edges <- edges %>%
mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
dbDisconnect(con)
return(edges)
}
index_new <- calculate_index(data, 6257, 100)
dbDisconnect()
library(sf)
library(dplyr)
library(purrr)
library(future.apply)
library(tictoc)
library(progressr)
#' Calculate green index for each edge
#'
#' This function calculates the green index for each edge in the road network.
#'
#' @param osm_data The OpenStreetMap data. This should be a list with three components:
#' highways, green_areas, and trees. Each component should be a spatial data frame.
#' You can use the osmdata package to get the required data.
#' @param crs_code The EPSG code for the Coordinate Reference System (CRS).
#' @param D The decay parameter in the decay function, default is 100.
#' @return A data frame with the green index for each edge.
#' @export
#' @examples
#' \dontrun{
#' # osm_data should be a list with three components: highways, green_areas, and trees
#' # You can use osmdata package to get this data.
#' calculate_green_index(osm_data, 2056, D = 100)
#' }
calculate_index <- function(osm_data, crs_code, D = 100) {
# Start timing
tic()
# Extract data from the list
highways_data <- osm_data$highways
green_areas_data <- osm_data$green_areas
trees_data <- osm_data$trees
# Transform data to specified CRS
highways_data <- highways_data$osm_lines %>% sf::st_transform(crs = crs_code)
green_areas_data <- green_areas_data$osm_polygons %>% sf::st_transform(crs = crs_code) %>% sf::st_union()
trees_data <- trees_data$osm_points %>% sf::st_transform(crs = crs_code)
# Define the distance decay functions
distance_decay_green_area <- function(edge, green_area) {
distance_to_green_area <- sf::st_distance(edge, green_area)
decay_function <- exp(-(distance_to_green_area / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
distance_decay_tree <- function(edge, trees) {
distances_to_trees <- sf::st_distance(edge, trees)
min_distance_to_tree <- min(distances_to_trees)
decay_function <- exp(-(min_distance_to_tree / D))
decay_function <- pmax(pmin(decay_function, 1), 0)
return(decay_function)
}
# Perform calculations in parallel with progress tracking
plan(multisession)
green_index_green_area <- future.apply::future_map(
highways_data$geometry,
function(edge) {
sum(purrr::map_dbl(green_areas_data, ~distance_decay_green_area(edge, .x)), na.rm = TRUE)
},
.progress = progressr::progressing(style = 3)
)
green_index_tree <- future.apply::future_map(
highways_data$geometry,
function(edge) {
distance_decay_tree(edge, trees_data)
},
.progress = progressr::progressing(style = 3)
)
# Combine the results
edges <- highways_data %>%
dplyr::mutate(
green_index_green_area = green_index_green_area,
green_index_tree = green_index_tree
)
# Compute normalized green index
edges <- edges %>%
dplyr::mutate(
green_index = (green_index_green_area + green_index_tree) / 2,
green_index = (green_index - min(green_index, na.rm = TRUE)) / (max(green_index, na.rm = TRUE) - min(green_index, na.rm = TRUE))
)
# Stop timing and print elapsed time
toc(log = TRUE)
return(edges)
}
dbDisconnect()
data <- get_osm_data("Oerlikon, Zurich")
index <- calculate_green_index(data, 2056, 100)
per1 <- calculate_percentage(index)
View(index)
run_app()
runApp()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
run_app()
library(greenR)
data <- get_osm_data("New Delhi, India")
green_areas_data <- data$green_areas
visualize_green_spaces(green_areas_data)
green_index <- calculate_green_index(data, 4326, 100)
percentage <- calculate_percentage(green_index)
print(percentage)
run_app()
run_app()
run_
run_app()
library(greenR)
run_app()
libary(green)
libary(greenR)
library(greenR)
data <- get_osm_data("New Delhi, India")
index <- calculate_green_index(data, 7760)
# Create an interactive plot using Leaflet
map <- plot_green_index(index, interactive = TRUE, base_map = "CartoDB.DarkMatter")
# To view the plot in the console, use:
print(map)
data <- get_osm_data("Gurugram, India")
index <- calculate_green_index(data, 7760)
# Create an interactive plot using Leaflet
map <- plot_green_index(index, interactive = TRUE, base_map = "CartoDB.DarkMatter")
# To view the plot in the console, use:
print(map)
run_app()
run_app()
run_app()
