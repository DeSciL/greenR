.legend-title {
font-weight: bold;
margin-bottom: 5px;
}
#controls {
position: absolute;
top: 10px;
left: 10px;
background: rgba(255,255,255,0.8);
padding: 10px;
border-radius: 3px;
font-family: Arial, sans-serif;
}
.control-group {
margin-bottom: 10px;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="legend" class="legend">
<div class="legend-title">%s</div>
</div>
<div id="controls">
<div class="control-group">
<label for="lineWidthSlider">Line Width: <span id="lineWidthValue">5</span></label>
<input type="range" id="lineWidthSlider" min="1" max="20" step="1" value="5">
</div>
<div class="control-group">
<label for="showBuildings">Show Buildings:</label>
<input type="checkbox" id="showBuildings">
</div>
</div>
<script>
mapboxgl.accessToken = "%s";
const map = new mapboxgl.Map({
container: "map",
style: "mapbox://styles/mapbox/streets-v11",
center: [%f, %f],
zoom: %d,
pitch: 45,
bearing: -17.6,
antialias: true
});
const data = %s;
let lineWidth = 5;
const colorScale = d3.scaleSequential(d3.%s).domain([0, 1]);
map.on("load", () => {
map.addSource("linestrings", {
type: "geojson",
data: data
});
map.addLayer({
id: "linestrings",
type: "line",
source: "linestrings",
paint: {
"line-width": lineWidth,
"line-color": [
"interpolate",
["linear"],
["get", "%s"],
0, colorScale(0),
1, colorScale(1)
]
}
});
// Insert the layer beneath any symbol layer.
const layers = map.getStyle().layers;
const labelLayerId = layers.find(
(layer) => layer.type === "symbol" && layer.layout["text-field"]
).id;
map.addLayer(
{
id: "3d-buildings",
source: "composite",
"source-layer": "building",
filter: ["==", "extrude", "true"],
type: "fill-extrusion",
minzoom: 15,
paint: {
"fill-extrusion-color": "#aaa",
"fill-extrusion-height": [
"interpolate",
["linear"],
["zoom"],
15,
0,
15.05,
["get", "height"]
],
"fill-extrusion-base": [
"interpolate",
["linear"],
["zoom"],
15,
0,
15.05,
["get", "min_height"]
],
"fill-extrusion-opacity": 0.6
}
},
labelLayerId
);
document.getElementById("lineWidthSlider").addEventListener("input", (event) => {
lineWidth = event.target.value;
document.getElementById("lineWidthValue").innerText = lineWidth;
map.setPaintProperty("linestrings", "line-width", parseInt(lineWidth));
});
document.getElementById("showBuildings").addEventListener("change", (event) => {
const visibility = event.target.checked ? "visible" : "none";
map.setLayoutProperty("3d-buildings", "visibility", visibility);
});
map.on("mouseenter", "linestrings", (e) => {
map.getCanvas().style.cursor = "pointer";
const coordinates = e.lngLat;
const greenIndex = e.features[0].properties["%s"];
new mapboxgl.Popup()
.setLngLat(coordinates)
.setHTML(`<strong>Green Index:</strong> ${greenIndex.toFixed(2)}`)
.addTo(map);
});
map.on("mouseleave", "linestrings", () => {
map.getCanvas().style.cursor = "";
const popups = document.getElementsByClassName("mapboxgl-popup");
while (popups[0]) {
popups[0].remove();
}
});
// Create continuous legend
const legend = document.getElementById("legend");
const legendWidth = 300;
const legendHeight = 10;
const canvas = document.createElement("canvas");
canvas.width = legendWidth;
canvas.height = legendHeight;
const ctx = canvas.getContext("2d");
const legendScale = d3.scaleSequential(d3.%s).domain([0, 1]);
for (let i = 0; i < legendWidth; ++i) {
const value = i / legendWidth;
ctx.fillStyle = legendScale(value);
ctx.fillRect(i, 0, 1, legendHeight);
}
legend.appendChild(canvas);
const legendValues = document.createElement("div");
legendValues.innerHTML = `
<div style="display: flex; justify-content: space-between;">
<span>0</span>
<span>0.5</span>
<span>1</span>
</div>
`;
legend.appendChild(legendValues);
});
map.addControl(new mapboxgl.NavigationControl());
</script>
</body>
</html>
', green_index_col, mapbox_token, map_center[1], map_center[2], map_zoom, data_json, color_palette, green_index_col, green_index_col, color_palette)
writeLines(html_content, output_file)
message("Linestring Map has been created: ", output_file)
# Automatically open the map in RStudio Viewer if available
if (rstudioapi::isAvailable()) {
rstudioapi::viewer(output_file)
} else if (interactive()) {
browseURL(output_file)
}
invisible(NULL)
}
create_linestring_map_js(index, "green_index", "pk.eyJ1Ijoic2FjaGl0Mjc5MCIsImEiOiJjbHhxMjRnNHIwdG1lMnJxcjV6cGluc3A1In0.NACDYBfi7PDrJgAvzImuVA")
# Declare global variables to avoid R CMD check warnings
utils::globalVariables(c("green_index", "green_index_green_area", "green_index_tree", ".", "osm_id", "geometry"))
#' Calculate Green Index
#'
#' This function calculates the green index for a given set of OpenStreetMap (OSM) data using DuckDB and Duckplyr.
#' The green index is calculated based on the proximity of highways to green areas and trees.
#'
#' @param osm_data List containing OSM data (highways, green_areas, trees).
#' @param crs_code Coordinate reference system code for transformations.
#' @param D Distance decay parameter (default = 100).
#' @param buffer_distance Buffer distance for spatial joins (default = 120).
#' @return A spatial data frame with calculated green index.
#' @importFrom sf st_transform st_union st_geometry st_as_text st_crs st_drop_geometry st_as_sf
#' @importFrom DBI dbConnect dbExecute dbWriteTable dbGetQuery dbDisconnect
#' @importFrom duckdb duckdb
#' @importFrom data.table as.data.table :=
#' @importFrom dplyr %>% select
#' @examples
#' \donttest{
#'   osm_data <- get_osm_data("Basel, Switzerland")
#'   green_index <- calculate_green_index(osm_data, 2056)
#' }
#' @export
calculate_index <- function(osm_data, crs_code, D = 100, buffer_distance = 120) {
# Start time
start_time <- Sys.time()
# Establish DuckDB connection
con <- DBI::dbConnect(duckdb::duckdb())
DBI::dbExecute(con, "INSTALL spatial;")
DBI::dbExecute(con, "LOAD spatial;")
# Extract and transform data
highways_data <- osm_data$highways
green_areas_data <- osm_data$green_areas
trees_data <- osm_data$trees
edges <- sf::st_transform(highways_data$osm_lines, crs = crs_code)
green_areas <- sf::st_transform(green_areas_data$osm_polygons, crs = crs_code) %>% sf::st_union()
trees <- sf::st_transform(trees_data$osm_points, crs = crs_code)
# Ensure CRS is correctly set
sf::st_crs(edges) <- crs_code
sf::st_crs(green_areas) <- crs_code
sf::st_crs(trees) <- crs_code
# Prepare data frames and add geometry as WKT
edges_df <- sf::st_drop_geometry(edges)
edges_df$geometry <- sf::st_as_text(sf::st_geometry(edges))
edges_df$id <- seq_len(nrow(edges_df))
green_areas_df <- data.frame(geometry = sf::st_as_text(sf::st_geometry(green_areas)))
trees_df <- data.frame(geometry = sf::st_as_text(sf::st_geometry(trees)))
# Check and rename duplicate columns
check_duplicate_columns(edges_df)
check_duplicate_columns(green_areas_df)
check_duplicate_columns(trees_df)
edges_df <- rename_duplicate_columns(edges_df)
green_areas_df <- rename_duplicate_columns(green_areas_df)
trees_df <- rename_duplicate_columns(trees_df)
# Write data frames to DuckDB
DBI::dbWriteTable(con, "edges", edges_df, overwrite = TRUE)
DBI::dbWriteTable(con, "green_areas", green_areas_df, overwrite = TRUE)
DBI::dbWriteTable(con, "trees", trees_df, overwrite = TRUE)
# Add and populate the geometry columns in DuckDB
DBI::dbExecute(con, "ALTER TABLE edges ADD COLUMN geom GEOMETRY;")
DBI::dbExecute(con, "UPDATE edges SET geom = ST_GeomFromText(geometry);")
DBI::dbExecute(con, "ALTER TABLE green_areas ADD COLUMN geom GEOMETRY;")
DBI::dbExecute(con, "UPDATE green_areas SET geom = ST_GeomFromText(geometry);")
DBI::dbExecute(con, "ALTER TABLE trees ADD COLUMN geom GEOMETRY;")
DBI::dbExecute(con, "UPDATE trees SET geom = ST_GeomFromText(geometry);")
# SQL query for green index calculation using ST_DWithin
query <- "
WITH green_area_distances AS (
SELECT
e.id,
MIN(ST_Distance(e.geom, g.geom)) AS distance
FROM
edges e
JOIN green_areas g ON ST_DWithin(e.geom, g.geom, ?)
GROUP BY e.id
),
tree_distances AS (
SELECT
e.id,
MIN(ST_Distance(e.geom, t.geom)) AS distance
FROM
edges e
JOIN trees t ON ST_DWithin(e.geom, t.geom, ?)
GROUP BY e.id
)
SELECT
e.id,
e.osm_id,
e.geometry,
COALESCE(exp(-gad.distance / ?), 0) AS green_index_green_area,
COALESCE(exp(-td.distance / ?), 0) AS green_index_tree
FROM
edges e
LEFT JOIN green_area_distances gad ON e.id = gad.id
LEFT JOIN tree_distances td ON e.id = td.id;
"
edges_df <- DBI::dbGetQuery(con, query, params = list(buffer_distance, buffer_distance, D, D))
# Convert result to data.table and calculate the green index
edges_dt <- data.table::as.data.table(edges_df)
edges_dt[, green_index := (green_index_green_area + green_index_tree) / 2]
min_green_index <- min(edges_dt$green_index, na.rm = TRUE)
max_green_index <- max(edges_dt$green_index, na.rm = TRUE)
edges_dt[, green_index := (green_index - min_green_index) / (max_green_index - min_green_index)]
# Set minimum green index value to 0.05 if it is 0
edges_dt[green_index == 0, green_index := 0.05]
edges_dt <- edges_dt[, .(osm_id, geometry, green_index_green_area, green_index_tree, green_index)]
edges <- sf::st_as_sf(edges_dt, wkt = "geometry", crs = crs_code)
# Disconnect DuckDB
DBI::dbDisconnect(con, shutdown = TRUE)
# End time
end_time <- Sys.time()
# Calculate and print processing time
processing_time <- end_time - start_time
message(paste("Processing time:", processing_time))
return(edges)
}
#' Helper function to rename duplicate columns
#' @param df Data frame with potential duplicate columns
#' @return Data frame with unique column names
rename_duplicate_columns <- function(df) {
colnames(df) <- make.unique(tolower(colnames(df)))
return(df)
}
#' Function to check for duplicate columns and print them
#' @param df Data frame to check for duplicate columns
#' @return Vector of duplicate column names
check_duplicate_columns <- function(df) {
dup_cols <- colnames(df)[duplicated(tolower(colnames(df)))]
if (length(dup_cols) > 0) {
message("Duplicate columns found:", paste(dup_cols, collapse = ", "))
} else {
message("No duplicate columns found.")
}
return(dup_cols)
}
index <- calculate_index(data, 6257, 100)
library(magrittr)
index <- calculate_index(data, 6257, 100)
create_linestring_map_js(index, "green_index", "pk.eyJ1Ijoic2FjaGl0Mjc5MCIsImEiOiJjbHhxMjRnNHIwdG1lMnJxcjV6cGluc3A1In0.NACDYBfi7PDrJgAvzImuVA")
green_areas_data <- data$green_areas
create_accessibility_map_js <- function(green_area_data, mapbox_token, output_file = "accessibility_map.html",
initial_zoom = 15, initial_pitch = 45, initial_bearing = -17.6) {
# Validate and prepare green area data
if (is.null(green_area_data) || !inherits(green_area_data$osm_polygons, "sf")) {
stop("Invalid green_area_data provided. It should be a non-null sf object.")
}
osm_sf <- green_area_data$osm_polygons
# Calculate the center of the bounding box
bbox <- sf::st_bbox(osm_sf)
initial_lat <- (bbox$ymin + bbox$ymax) / 2
initial_lon <- (bbox$xmin + bbox$xmax) / 2
# Convert green area data to GeoJSON
temp_geojson <- tempfile(fileext = ".geojson")
sf::st_write(osm_sf, temp_geojson, driver = "GeoJSON")
green_area_data_json <- paste(readLines(temp_geojson), collapse = "\n")
# Create HTML content
html_content <- sprintf('
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Accessibility Analysis</title>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%%; }
.legend {
position: absolute;
bottom: 30px;
right: 10px;
background: rgba(255,255,255,0.8);
padding: 10px;
border-radius: 3px;
font-family: Arial, sans-serif;
font-size: 12px;
}
.legend-title {
font-weight: bold;
margin-bottom: 5px;
}
#controls {
position: absolute;
top: 10px;
left: 10px;
background: rgba(255,255,255,0.8);
padding: 10px;
border-radius: 3px;
font-family: Arial, sans-serif;
}
.control-group {
margin-bottom: 10px;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="controls">
<div class="control-group">
<label for="walkTimeSlider">Walking Time (minutes): <span id="walkTimeValue">15</span></label>
<input type="range" id="walkTimeSlider" min="1" max="30" step="1" value="15">
</div>
</div>
<script>
mapboxgl.accessToken = "%s";
const map = new mapboxgl.Map({
container: "map",
style: "mapbox://styles/mapbox/light-v11",
center: [%f, %f],
zoom: %f,
pitch: %f,
bearing: %f,
antialias: true
});
let currentMarker;
map.on("load", () => {
// Load green spaces data
map.addSource("green_spaces", {
type: "geojson",
data: %s
});
map.addLayer({
id: "green_spaces_layer",
type: "fill",
source: "green_spaces",
paint: {
"fill-color": "green",
"fill-opacity": 0.5,
"fill-outline-color": "black"
}
});
// Event listener for clicking on the map to add a marker
map.on("click", (e) => {
const coordinates = e.lngLat;
if (currentMarker) {
currentMarker.remove();
}
currentMarker = addMarker(coordinates);
generateIsochrones(coordinates, getWalkingTime());
});
// Function to add a marker at the specified coordinates
function addMarker(coordinates) {
return new mapboxgl.Marker({ color: "blue" })
.setLngLat(coordinates)
.addTo(map);
}
// Function to get the current walking time from the slider
function getWalkingTime() {
return parseInt(document.getElementById("walkTimeSlider").value);
}
// Function to generate isochrones
function generateIsochrones(coordinates, walkingTime) {
const url = `https://api.mapbox.com/isochrone/v1/mapbox/walking/${coordinates.lng},${coordinates.lat}?contours_minutes=5,10,${walkingTime}&polygons=true&access_token=${mapboxgl.accessToken}`;
fetch(url)
.then(response => response.json())
.then(data => {
if (map.getSource("isochrones")) {
map.getSource("isochrones").setData(data);
} else {
map.addSource("isochrones", {
type: "geojson",
data: data
});
map.addLayer({
id: "isochrones_layer",
type: "fill",
source: "isochrones",
paint: {
"fill-color": [
"step",
["get", "contour"],
"#ffffcc",
5, "#a1dab4",
10, "#41b6c4",
15, "#2c7fb8",
20, "#253494"
],
"fill-opacity": 0.5
}
});
// Add hover functionality for the isochrones
map.on("mouseenter", "isochrones_layer", (e) => {
map.getCanvas().style.cursor = "pointer";
const properties = e.features[0].properties;
new mapboxgl.Popup()
.setLngLat(e.lngLat)
.setHTML(`<strong>Walking Time:</strong> ${properties.contour} minutes`)
.addTo(map);
});
map.on("mouseleave", "isochrones_layer", () => {
map.getCanvas().style.cursor = "";
const popups = document.getElementsByClassName("mapboxgl-popup");
while (popups[0]) {
popups[0].remove();
}
});
}
});
}
});
// Update walking time value display
document.getElementById("walkTimeSlider").addEventListener("input", (event) => {
document.getElementById("walkTimeValue").innerText = event.target.value;
});
map.addControl(new mapboxgl.NavigationControl());
</script>
</body>
</html>',
mapbox_token, initial_lon, initial_lat, initial_zoom, initial_pitch, initial_bearing, green_area_data_json)
# Write the HTML content to the specified output file
writeLines(html_content, output_file)
message("Accessibility Map has been created: ", output_file)
# Automatically open the map in RStudio Viewer if available
if (rstudioapi::isAvailable()) {
rstudioapi::viewer(output_file)
} else if (interactive()) {
browseURL(output_file)
}
invisible(NULL)
}
create_accessibility_map_js(green_areas_data, "pk.eyJ1Ijoic2FjaGl0Mjc5MCIsImEiOiJjbHhxMjRnNHIwdG1lMnJxcjV6cGluc3A1In0.NACDYBfi7PDrJgAvzImuVA")
run_app()
runApp('inst/shiny')
data <- get_osm_data("OErlikon, Zurich")
index <- calculate_green_index(data, 2056, 100)
mapbox_token <- "pk.eyJ1Ijoic2FjaGl0Mjc5MCIsImEiOiJjbHhxMjRnNHIwdG1lMnJxcjV6cGluc3A1In0.NACDYBfi7PDrJgAvzImuVA"
create_linestring_3D(index, "green_index", mapbox_token)
green_areas_data <- data$green_areas
visualize_green_spaces(green_areas_data)
green_space_clustering(green_areas_data, num_clusters = 2)
accessibility_3D(green_areas_data, mapbox_token)
points <- convert_to_point(index)
create_hexmap_3D(data=points, lon_col = "lon", lat_col = "lat", value_col = "green_index")
create_hexmap_3D(data=points, lon_col = "lon", lat_col = "lat", value_col = "green_index", output_file = "zurich_green_index_map.html")
create_hexmap_3D(data=points, lon_col = "lon", lat_col = "lat", value_col = "green_index", mapbox_token = mapbox_token, output_file = "zurich_green_index_map.html")
percentage <- calculate_percentage(green_index)
percentage <- calculate_percentage(index)
percentage
runApp('inst/shiny')
